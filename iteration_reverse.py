'''
1. Выбрать начальное приближение для собственного числа матрицы.
2. Решить систему (A - λ*I)x = b, где A - исходная матрица, λ - приближение
 к собственному числу, I - единичная матрица, b - некоторый начальный вектор.
3. Нормировать полученный вектор x.
4. Обновить приближение к собственному числу: λ_new = (x^T*A*x)/(x^T*x),
 где x^T - транспонированный вектор x.
5. Если разность между новым и старым приближениями к собственному числу меньше
 некоторого порога, то закончить процесс. Иначе вернуться к шагу 2.

'''

from typing import Tuple
import numpy as np


def reverse_iteration(A: np.ndarray, eps: float) -> Tuple[float, np.ndarray]:
    # Выбор начального приближения для собственных чисел
    x = np.random.rand(A.shape[0])
    λ = np.random.rand()

    # Решение системы Ax = b и нормирование полученного вектора
    x = np.linalg.solve(A - λ * np.eye(A.shape[0]), x)
    x = x / np.linalg.norm(x)

    # Обновление приближения к собственному числу
    λ_new = (x.T @ A @ x) / (x.T @ x)
    # k = 0
    while abs(λ - λ_new) > eps:
        # k += 1

        # Обновление приближения к собственному числу и нормирование вектора x
        λ = λ_new
        x = np.linalg.solve(A - λ * np.eye(A.shape[0]), x)
        x = x / np.linalg.norm(x)

        # Обновление приближения к собственному числу
        λ_new = (x.T @ A @ x) / (x.T @ x)
    # print("k = ", k)
    # Возвращение найденного собственного числа и соответствующего ему собственного вектора
    return λ_new, x


if __name__ == "__main__":
    a = [[5, 6, -3],
         [-1, 0, 1],
         [1, 2, -1]]
    print("a = ", a)

    print(reverse_iteration(np.array(a), eps=0.001))
